# Testes automatizados üß™

## O que s√£o testes automatizados?

S√£o testes executados por c√≥digo para verificar se um sistema funciona corretamente, sem a necessidade de testes manuais.

## Por que us√°-los?

‚úÖ Evita erros ‚Üí Detecta problemas antes que afetem os usu√°rios.  
‚úÖ Economiza tempo ‚Üí Automatiza tarefas repetitivas.  
‚úÖ Garante qualidade ‚Üí Mant√©m o c√≥digo funcionando ap√≥s mudan√ßas.  
‚úÖ Facilita manuten√ß√£o ‚Üí Ajuda a evitar que novas funcionalidades quebrem o sistema.

## Instalando pacote

Nesta se√ß√£o vamos utilizar o `jest` para realizar os testes, para isso digite no terminal

    npm i jest --save-de

agora dentro do package.json, dentro do objeto _script_ adicione

```json
script: {
    "start": "node src/index.js",
    "dev":"env-cmd ./config/dev.env nodemon src/index.js",
    "test":"jest"
}
```

No terminal vamos executar nossos testes usando o comando:

    npm test

vamos obter um erro no terminal pois ainda n√£o criamos uma arquivo de teste. Para fazer isso, crie uma nova pasta no diret√≥rio `src` chamada `tests` e dentro adicione arquivos com nome como:

    math.test.js

Em fun√ß√£o da extens√£o do arquivo o jest ser√° capaz de encontrar o arquivo para testar.

Aqui vamos come√ßar com testes simples, veja o exemplo abaixo:

```javascript
test("Ol√°, Mundo!", () => {
  // Se deixamos vazio e rodarmos o test n√£o dar√° erro
});

test("Esse test vai falhar", () => {
  // Esse teste vai falhar
  throw new Errro("Falhar!");
});
```

Agora crie um arquivo externo `math.js` onde adicionamos a fun√ß√£o:

```javascript
function sum(num1, num2) {
  return num1 + num2;
}

module.exports = {
  sum,
};
```

√© uma fun√ß√£o simples mas vai servir para nossos testes iniciais. Agora dentro do nosso arquivo `math.test.js` vamos importar a fun√ß√£o acima e usar `sum` nos nossos testes.

```javascript
const { sum } = require("./math");

// Teste 1
test("obter soma", () => {
  const soma = sum(1, 2);
  expect(soma).toBe(3);
});

// Teste 2
test("Nome deve ser igor", () => {
  const name = "Alan";
  expect(name).toBe("igor");
});
```

## Testando c√≥digos assincronos

Antes de come√ßar a aprender como fazer testes em c√≥digos assincronos, devemos alterar o arquivo `package.json` para que os testes sejam executados automaticamente sem precisar executar manualmente os testes no terminal Para isso, fazemos

```json
script: {
    "start": "node src/index.js",
    "dev":"env-cmd ./config/dev.env nodemon src/index.js",
    "test":"jest --watch"
}
```

pronto, agora os testes ser√£o executados automaticamente a medida que alteremos os arquivos de teste e salvamos. Rode no terminal o `npm run test` e veja que o terminal n√£o √© mais liberado ap√≥s a execu√ß√£o.

Vamos iniciar nossos testes, veja o c√≥digo abaixo:

```javascript
test("Async Demo", () => {
  setTimeOut(() => {
    expect(1).toBe(2);
  }, 2000);
});
```

se salvarmos o c√≥digo acima veremos que o n√£o teremos nenhum erro, o que claramente √© um erro, pois `expect(1).toBe(2);` est√° errado. Isso acontece pq o jest n√£o sabe que o c√≥digo em quest√£o se trata de um c√≥digo assincrono. Para resolver isso, precisamos dizer ao jest para finalizar o teste, somente quando tudo estiver feito(done), ou seja:

```javascript
test("Async Demo", (done) => {
  setTimeOut(() => {
    expect(1).toBe(2);
    done();
  }, 2000);
});
```

quando o `setTimeOut` terminar de executar, o m√©todo `done()` ser√° executado e o jest finalizar√° os testes com os resultados. Se olhar no terminal agora veremos um erro, o que era o resultado esperado.

Vamos adicionar um outra fun√ß√£o ao nossos testes para tornar as coisas um pouco mais dificeis. Veja o c√≥digo abaixo:

```javascript
function sum(num1, num2) {
  return num1 + num2;
}

const add = (a, b) => {
  return new Promise(resolve, (reject) => {
    setTimeout(() => {
      if (a < 0 || b < 0) {
        console.log("Numbers must be non-negative");
      }

      resolve(a + b);
    }, 2000);
  });
};

module.exports = {
  sum,
  add,
};
```

adicionamos a fun√ß√£o `add` que √© assicrona para trabalhar melhor com processos assincronos. Agora vamos iniciar nossos testes. Como a fun√ß√£o `add` √© assincrona, ent√£o usamos o `then()` para resolver a promisse. Uma vez resolvida, usamos o retorno para executar nossos testes da mesma forma que fizemos at√© aqui.

```javascript
test("obter a soma de dois n√∫meros", (done) => {
  add(2, 3).then((sum) => {
    expect(sum).toBe(5);
    done();
  });
});
```

podemos escrever o c√≥digo acima usando `async/await`, que √© mais usado e fica como:

```javascript
test("obter a soma de dois n√∫meros", async () => {
  const sum = await add(1, 2);
  expect(sum).toBe(3);
});
```

## Testando aplica√ß√£o express part I

Nesta se√ß√£o alguns arquivos ser√£o modificados, uma vez que ser√£o usados para executar testes dentro de uma API. A primeira altera√ß√£o a ser feita √© no arquivo .env, aqui ser√° criado outro arquivo com o nome `teste.env` onde ser√° adicionado uma copia dos dados do arquivo `.env`. Os testes executado pelo jest na nossa API, afeta a base de dados, uma vez que os testes s√£o como solicita√ß√µes reais a nossa API. Esse n√£o √© o comportamento desejado, em fun√ß√£o disso, vamos usar uma base de dados local para executar os testes dentro da nossa API. No `teste.env` adicione:

    DB_URL= mongodb://127.0.0.1:27017/auth

Lembrando que possivelmente haver√° outras vari√°veis de ambiente dentro do arquivo `.env`, as mantenham como est√£o, altere somente a base de dados na URL.

Como os testes ser√£o executados usando o arquivo `teste.env` vamos configurar o jest para usar esse arquivo.

Primeiro, vamos instalar o pacote `env-cmd` digitando no terminal:

    npm i env-cmd --save-dev

agora, dentro do package.json altere os dados para:

```json
"scripts": {
    "start": "node server.js",
    "server": "nodemon server.js",
    "test": "env-cmd -f test.env jest --watch"
  },
  "jest": {
    "testEnvironment": "node"
  },
```

Agora quando for executar nossos testes, √© s√≥ digitar npm test no terminal.

## Testando aplica√ß√£o express part II

Aqui antes de iniciar o teste vamos instalar um novo pacote do node, chamado supertest:

    npm i supertest

Uma outra altera√ß√£o que devemos fazer √© na estrutura do nosso servidor, uma vez que o jest executa testes sem que o servidor esteja rodando, dado que ao iniciar o servidor ele bloqueia a porta onde √© feita os testes. Para evitar comportamentos indesejados, vamos criar na raiz do projeto vamos criar um arquivo chamado `app.js`, onde vamos adicionar o parte do c√≥digo que est√° dentro do `server.js`.

#### server.js

```javascript
const app = require("./app"); // importando outro parte do servidor

// server config
const port = process.env.port || 5000;

// Servidor
app.listen(port, () => {
  console.log("Servidor On");
  console.log(`Acesse em http://localhost:${port}`);
});
```

#### app.js

```javascript
require("dotenv").config();
const express = require("express");
const cors = require("cors");

const app = express();

require("./src/db/dbConnection");

// Routes
const routes = require("./src/routes/routes");

// Database Connection
require("./src/db/dbConnection");

// Middlewares
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use(
  cors({
    origin: "http://localhost:5173",
    methods: ["GET", "POST", "PUT", "DELETE"],
    allowedHeaders: ["Content-Type", "Authorization"],
    credentials: true,
  })
);

app.get("/", (req, res) => {
  res.status(200).json({ message: "Bem vindo ao servidor" });
});

app.use(routes);

module.exports = app; // Exportanto para o arquivo server.js
```

Para iniciar nossos testes, vamos importar o app.js dentro do nosso arquivo `users.test.js` que foi criado dentro da pasta /src/test

## Teste 1 - Testando cadastrar usu√°rio na API

```javascript
const request = require("supertest");

const app = require("../app");

test("Deve cadastrar usu√°rio", async () => {
  await request(app)
    .post("/users")
    .send({
      name: "igor",
      email: "igor@gmail.com",
      password: "12346",
    })
    .expect(201);
});
```

Se j√° houver algum usu√°rio com esses dados cadastrados, o teste lan√ßar√° um erro.

## Configura√ß√£o jest e desmontagem

No exemplo acima temos um usu√°rio sendo adicionado √† base de dados, se executarmos o mesmo teste mais de uma vez, na segunda execu√ß√£o o teste lan√ßar√° um erro, uma vez que os testes realizados pelo jest realmente afetam a base de dados, ou seja, o usu√°rio realmente √© adicionado na base e quando rodamos o mesmo teste de maneira subsequente, o que ocorre √© que nossa API lan√ßa um erro, uma vez que o dado que estamos tentando adicionar j√° existe na base de dados. Para resolver esse problema, devemos desmontar a base de dados ap√≥s o teste.

```javascript
// Essa fun√ß√£o ser√° executada antes de teste
beforeEach(() => {});
```

```javascript
// Essa fun√ß√£o ser√° executada antes de teste
afterEach(() => {});
```

podemos executar qualquer l√≥gica dentro dos m√©todos acima, e elas ser√£o executadas antes e depois de cada teste. Um exemplo de uso comum desses m√©todos dentro dos nossos testes √© o de limpar a base de dados antes ou depois de executar os testes, isso evita que os testes que executamos lancem erros.

```javascript
const User = require("../src/model/userModel");

beforeEach(async () => {
  await User.deleteMany();
});
```

ou

```javascript
const User = require("../src/model/userModel");

afterEach(async () => {
  await User.deleteMany();
});
```

Agora vamos testar a rota de login da nossa aplica√ß√£o, e se repararmos acima, todos os dados da nossa base s√£o removidos ap√≥s os testes de `cadastro`, o que √© um problema para o caso do teste de login, uma vez que nesse caso, devemos ter um usu√°rio cadastrado na base de dados. Para resolver esse problemas, vamos precisar alterar um pouco nosso c√≥digo.

```javascript
const request = require("supertest");

const app = require("../app");
const mongoose = require("mongoose");
const User = require("../src/model/userModel");

const user = {
  name: "Paula",
  email: "paula@gmail.com",
  password: "12346",
};

beforeEach(async () => {
  await User.deleteMany();
  await new User(user).save();
});

test("Deve cadastrar usu√°rio", async () => {
  await request(app)
    .post("/users")
    .send({
      name: "igor",
      email: "igor@gmail.com",
      password: "12346",
    })
    .expect(201);
});
```

Agora temos um usu√°rio permanente na base de dados e podemos executar o teste de login, analise o c√≥digo abaixo

```javascript
const request = require("supertest");

const app = require("../app");
const mongoose = require("mongoose");
const User = require("../src/model/userModel");

const user = {
  userName: "Paula",
  email: "paula@gmail.com",
  password: "12346",
};

beforeEach(async () => {
  await User.deleteMany();
  await new User(user).save();
});

//  Teste rota cadastro ‚úÖ
test("Deve cadastrar usu√°rio", async () => {
  await request(app)
    .post("/users")
    .send({
      name: "igor",
      email: "igor@gmail.com",
      password: "12346",
    })
    .expect(201);
});

// Teste de erro rota cadastro ‚ùå
test("N√£o deve cadastrar usu√°rio", async () => {
  await request(app)
    .post("/users")
    .send({
      name: "i", // Dado inv√°lido
      email: "igor@", // Dado inv√°lido
      password: "12", // Dado inv√°lido
    })
    .expect(201);
});

//  Teste rota Login ‚úÖ
test("Deve fazer login usu√°rio", async () => {
  await request(app)
    .post("/users/login")
    .send({
      email: user.email,
      password: user.password,
    })
    .expect(200);
});

//  Teste de falha rota Login ‚ùå
test("Deve falhar ao realizar login do usu√°rio", async () => {
  await request(app)
    .post("/users/login")
    .send({
      email: "andre@hotmail.com", // Usu√°rio n√£o cadastrado
      password: user.password,
    })
    .expect(200);
});

afterAll(async () => {
  await mongoose.connection.close(); // Fecha conex√£o com a base de dados ap√≥s testes
});
```

## Testando rotas privadas

Rotas privadas s√£o aquelas que os usu√°rios precisam possuir um token para poder acessa-las. Esse token √© decodificado e verificado sua validade pelo servidor, de modo que o usu√°rio possa acessar servi√ßos e dados confidenciais associados a sua conta. Os testes executados at√© o momento foram realizados em rotas p√∫blicas, onde n√£o era necess√°rio o usu√°rio possuir um token para poder acessa-las. Entretanto, nos testes subsequentes, as rotas ser√£o privadas e precisaremos adicionar um `Id` √† nossa usu√°ria permanente, e com esse Id vamos criar um token de acesso para a usu√°ria.

Utilizamos o mongoose para criar um `ObjectId`, esse dado ser√° o valor do campo `_id` do documento user. Com esse dado obtido, podemos gerar um token para o user usando o m√©todo `.sign()` do `jsonwebtoken`, passando o **userOneId** como payload, o **JWT_SECRET** para segredo e o tempo de expira√ß√£o do token ao final. O processo detalhado pode ser visualizado no c√≥digo abaixo.

```javascript
const request = require("supertest");

const app = require("../app");
const mongoose = require("mongoose");
const User = require("../src/model/userModel");

const jwt = require("jsonwebtoken");

// Aqui estamos criando o id e associando a usu√°ria permanente
const userOneId = new mongoose.Types.ObjectId();

const user = {
  _id: userOneId,
  userName: "Paula",
  email: "paula@gmail.com",
  password: "12346",
  tokens: [{ token: jwt.sign({ _id: userOneId }, process.env.JWT_SECRET) }],
};
```

Agora que nosso usu√°rio possui um token associado, podemos unir os testes as rotas privadas aos testes que j√° executamos at√© aqui, com a diferen√ßa de que, agora devemos nos atentar aos m√©todos exigidos em cada um dos testes e no fato de que precisaremos enviar nosso token via m√©todo `.set()`. Veja os testes 5 e 6 abaixo.

```javascript
const request = require("supertest");

const app = require("../app");
const mongoose = require("mongoose");
const User = require("../src/model/userModel");

const jwt = require("jsonwebtoken");

// Aqui estamos criando o id e associando a usu√°ria permanente
const userOneId = new mongoose.Types.ObjectId();

const user = {
  _id: userOneId,
  userName: "Paula",
  email: "paula@gmail.com",
  password: "12346",
  tokens: [{ token: jwt.sign({ _id: userOneId }, process.env.JWT_SECRET) }],
};

beforeEach(async () => {
  await User.deleteMany();
  await new User(user).save();
});

  // 1 - Teste rota cadastro ‚úÖ
  test("Deve cadastrar usu√°rio", async () => {
    await request(app)
      .post("/users")
      .send({
        name: "igor",
        email: "igor@gmail.com",
        password: "12346",
      })
      .expect(201);
  });

  // 2 - Teste de erro rota cadastro ‚ùå
  test("N√£o deve cadastrar usu√°rio", async () => {
    await request(app)
      .post("/users")
      .send({
        name: "i", // Dado inv√°lido
        email: "igor@", // Dado inv√°lido
        password: "12", // Dado inv√°lido
      })
      .expect(201);
  });

  // 3 - Teste rota Login ‚úÖ
  test("Deve fazer login usu√°rio", async () => {
    await request(app)
      .post("/users/login")
      .send({
        email: user.email,
        password: user.password,
      })
      .expect(200);
  });

  // 4 - Teste de falha rota Login ‚ùå
  test("Deve falhar ao realizar login do usu√°rio", async () => {
    await request(app)
      .post("/users/login")
      .send({
        email: "andre@hotmail.com", // Usu√°rio n√£o cadastrado
        password: user.password,
      })
      .expect(200);
  });

 // 5- Teste para obter informa√ß√µes do usu√°rio ‚úÖ
  test("Obter dados do perfil do usu√°rio", async () => {
    await request(app)
      .get("/users/profile")
      .set("Authorization", `Bearer ${user.tokens[0].token}`)
      .send()
      .expect(200);
  });

  // 6 - Teste de falha da rota de obter dados do usu√°rio ‚ùå
  test('N√£o deve retornar dados do usu√°rio, token n√£o foi enviado', async () => {
     await request(app)
          .get('/users/profile')
          .set('Authorization', `Bearer ${}`)
          .send()
          .expect(403)
  })

afterAll(async () => {
  await mongoose.connection.close(); // Fecha conex√£o com a base de dados ap√≥s testes
});
```

## Teste rota delete

Agora chegou o momento de verificarmos se nossa API est√° removendo os dados corretamente, para isso, vamos adicionar aos nossos testes, o de n√∫mero 7 e 8 mostra no c√≥digo abaixo.

```javascript
// 7 - Teste de remo√ß√£o da conta do usu√°rio ‚úÖ

test("Deve remover o usu√°rio", async () => {
  await request(app)
    .delete("/users/profile")
    .set("Authorization", `Bearer ${user.tokens[0].token}`)
    .send()
    .expect(200);
});

// 8 - Teste de falha ao remover da conta do usu√°rio, usu√°rio n√£o autorizado ‚ùå

test("Deve remover o usu√°rio", async () => {
  await request(app)
    .delete("/users/profile")
    .set("Authorization", ``)
    .send()
    .expect(403);
});
```

## Declara√ß√µes avan√ßadas

Podemos fazer testes mais avan√ßados, verificando se dados foram de fato salvos na base de dados, se o token foi gerado como esperado entre outros, veja alguns exemplos abaixo.

```js
test("Deve cadastrar novo usu√°rio", async () => {
  // Envia uma requisi√ß√£o POST para cadastrar um novo usu√°rio
  const response = await request(app)
    .post("/users/signup")
    .send({
      name: "Andrew",
      email: "andrew@example.com",
      password: "MyPass777!",
    })
    .expect(201); // Espera que o status da resposta seja 201 (Created)

  // Verifica se o usu√°rio foi salvo corretamente no banco de dados
  const user = await User.findById(response.body.user._id);
  expect(user).not.toBeNull(); // O usu√°rio deve existir no banco

  // Verifica√ß√µes sobre a resposta da API
  expect(response.body).toMatchObject({
    user: {
      name: "Andrew",
      email: "andrew@example.com",
    },
    token: user.tokens[0].token, // O token gerado deve ser igual ao armazenado no banco
  });

  // Garante que a senha salva no banco est√° criptografada
  expect(user.password).not.toBe("MyPass777!");
});
```

## Mocking libraries

No contexto dos testes automatizados, **Mocking Libraries** s√£o bibliotecas usadas para criar objetos simulados que imitam o comportamento de depend√™ncias externas, como bancos de dados, APIs ou fun√ß√µes de terceiros. Isso permite testar partes espec√≠ficas do c√≥digo sem depender desses servi√ßos externos, tornando os testes mais r√°pidos, isolados e previs√≠veis.

Para criar nossos mocks, vamos criar uma pasta chamada `__mocks__` dentro da pasta onde estamos rodando nossos testes.
Dentre da pasta vamos adicionar uma pasta com o nome do modulo que queremos recriar com o @ na frente do nome `@sendgrid`, por exemplo, e dentro dessa pasta vamos adicionar um arquivo.js.

Quando estamos criando um mock de uma api externa √© importante garantir que nosso mock tenha exatamente as mesmas fun√ß√µes da Api original. Por exemplo:

```js
const sgMail = require("@sendgrid/mail");

sgMail.setApiKey(process.env.SENDGRID_API_KEY);

const sendWelcomeEmail = (email, name) => {
  sgMail.send({
    to: email,
    from: 'Igorfonseca@gmail.com',
    subject: 'Thanks for joining in!'
    text: 'Bem vindo a API'
  })
}

const sendCancelationEmail = (email, name) => {
  sgMail.send({
    to: email,
    from: 'Igorfonseca@gmail.com',
    subject: 'Thanks for joining in!'
    text: 'Triste por te ver partir...'
  })
}

```

acima temos um pacote que envia email ao usu√°rio quando ele cria ou remove sua conta. Vamos criar um mock desse pacote para simular o comportamento de enviar email e podermos testar nossa API sem gastar da cota gratuita. Repare que no c√≥digo acima utilizamos dois m√©todos, o `setApiKey()` e o `.send()`, e nenhum deles retorna algo. Ent√£o ser√° esses dois m√©todos que vamos simular o comportamento.

Dentro no arquivo.js na pasta dentro de `__mock__` fazemos:

```js
module.exports = {
  setApiKey() {},
  send() {},
};
```

Agora √© s√≥ criar um test para a rota de criar...

## Teste de rotas com envio de arquivos

Na nossa API, existe a rota onde o usu√°rio deve anexar uma foto para ser usada como foto de perfil, aqui vamos aprender como podemos testar esse tipo de rota enviando uma arquivo em anexo. Para isso vamos criar dentro da pasta `__mocks__` uma nova pasta chamada `fixture`, onde vamos adicionar o arquivo que queremos enviar no teste. Uma vez com esse passo tendo sido feito, vamos escrever o teste como mostrado abaixo.

```js
test("Deve fazer envio de imagem", async () => {
  await request(app)
    .post("/profile/photo")
    .set("Authorization", `Bearer ${user.tokens[0].token}`)
    .attach("profile img", "caminho at√© a imagem")
    .expect(200);

  const user = await User.findById(userId);
  expect(user.avatar).toEqual(expect.any(Buffer));
});
```

O teste acima √© para o caso de estar salvando a imagem de perfil dentro do documento na base de dados, o que n√£o √© recomendado. Neste caso devemos usar um servi√ßo externo de armazenamento de imagens e salvar a URL da imagem que o servi√ßo como o Claudinary fornece. Se estiver usando esses servi√ßos para realizar os testes ser√° necess√°rio fazer um mock do `multer` e `cloudinary`. Para o caso do multer podemos fazer algo como:

```js
jest.mock("multer", () => {
  return () => ({
    single: jest.fn(() => (req, res, next) => next()),
    array: jest.fn(() => (req, res, next) => next()),
    fileds: jest.fn(() => (req, res, next) => next()),
  });
});
```

abaixo explico detalhadamente a estrutura do c√≥digo acima

1Ô∏è‚É£ `jest.mock('multer', () => {...})`
Aqui, estamos dizendo ao Jest para substituir o m√≥dulo multer por um mock personalizado.

2Ô∏è‚É£ `return () => ({ ... })`
O multer exporta uma fun√ß√£o, ent√£o nosso mock precisa imitar isso. Quando chamamos multer(), ele retorna um objeto que cont√©m m√©todos (single, array, fields).

3Ô∏è‚É£ `single: jest.fn(() => (req, res, next) => next())`
A fun√ß√£o single() recebe o nome de um campo de arquivo (upload.single('file')) e retorna um middleware Express.

- No c√≥digo original, o multer processaria o arquivo antes de chamar next().

- No mock, apenas chamamos next() diretamente, simulando um upload sem processar nada.

4Ô∏è‚É£ array() e fields()
Eles seguem a mesma l√≥gica de single(), mas para m√∫ltiplos arquivos.

Por fim para verificar se o multer foi chamado, no teste podemos incluir um

```js
expect(multer().single).toHaveBeenCalled();
```

Isso confirma que o multer foi instanciado e utilizado no c√≥digo.

Para o caso Cloudinary podemos fazer:

```js
jest.mock("multer-storage-cloudinary", () => ({
  CloudinaryStorage: jest.fn(() => ({
    _handleFile: jest.fn((req, file, cb) => cb(null, { path: "mock-url" })),
    _removeFile: jest.fn((req, file, cb) => cb(null)),
  })),
}));
```

## Testes para rota de atualiza√ß√£o de dados

Algumas rotas da nossa aplica√ß√£o s√£o utilizadas para atualizar os dados dos usu√°rios, abaixo mostro como testar essas rotas.

```js
test("Deve atualizar campos validos do usu√°rio", async () => {
  await request(app)
    .post("/users/profile")
    .set("Authorization", `Bearer ${user.tokens[0].token}`)
    .send({
      name: "Alex",
    })
    .expect(200);

  const user = await findById(userID);
  expect(user.name).toEqual("Alex");
});
```
